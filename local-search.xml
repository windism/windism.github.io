<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【社区发现算法】Leiden算法</title>
    <link href="/1876331718.html"/>
    <url>/1876331718.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Community Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Community Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【社区发现算法】LPA算法</title>
    <link href="/1876331716.html"/>
    <url>/1876331716.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Label Propagation Algorithm</code> 标签传播算法(LPA)由<code>Raghavan</code>等人于2007提出.</p><ul><li>论文: <a href="https://arxiv.org/abs/0709.2938">《Near linear time algorithm to detect community structures in large-scale networks》</a>.</li><li>思想: 节点标签完全由其直接邻居决定; 典型基于标签传播的局部社区发现算法.</li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>初始化图中节点标签; 即节点<code>i</code>对应标签<code>i</code></li><li>遍历图节点, 针对单个节点，获取其邻居标签，找到出现次数最大的标签, 若出现最多标签不止一个, 则随机选择一个标签替换成该节点标签</li><li>重复步骤2, 直至节点标签不再变化或者达到最大迭代次数</li></ol><h3 id="GraphX调用"><a href="#GraphX调用" class="headerlink" title="GraphX调用"></a>GraphX调用</h3><p>参考代码<a href="https://github.com/apache/spark/blob/v3.4.0/graphx/src/main/scala/org/apache/spark/graphx/lib/LabelPropagation.scala">LabelPropagation.scala</a>, 源码解读:</p><figure><div class="code-wrapper"><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">def</span> run<span class="token punctuation">[</span>VD<span class="token punctuation">,</span> ED<span class="token operator">:</span> ClassTag<span class="token punctuation">]</span><span class="token punctuation">(</span>graph<span class="token operator">:</span> Graph<span class="token punctuation">[</span>VD<span class="token punctuation">,</span> ED<span class="token punctuation">]</span><span class="token punctuation">,</span> maxSteps<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> Graph<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> ED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  require<span class="token punctuation">(</span>maxSteps <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Maximum of steps must be greater than 0, but got </span><span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token expression">maxSteps</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>  <span class="token comment">// Step 1: 初始化图, 重设节点属性(标签)为其ID</span>  <span class="token keyword">val</span> lpaGraph <span class="token operator">=</span> graph<span class="token punctuation">.</span>mapVertices <span class="token punctuation">&#123;</span> <span class="token keyword">case</span> <span class="token punctuation">(</span>vid<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token keyword">=></span> vid <span class="token punctuation">&#125;</span>  <span class="token comment">// Step 2.1: 双向发送消息: 标签->1(可改成权重)</span>  <span class="token keyword">def</span> sendMessage<span class="token punctuation">(</span>e<span class="token operator">:</span> EdgeTriplet<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> ED<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token punctuation">[</span><span class="token punctuation">(</span>VertexId<span class="token punctuation">,</span> Map<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    Iterator<span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>srcId<span class="token punctuation">,</span> Map<span class="token punctuation">(</span>e<span class="token punctuation">.</span>dstAttr <span class="token operator">-></span> <span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>dstId<span class="token punctuation">,</span> Map<span class="token punctuation">(</span>e<span class="token punctuation">.</span>srcAttr <span class="token operator">-></span> <span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// Step 2.2: 合并接受消息: 将收到信息进行聚合, 形成 标签->数量 的字典结构</span>  <span class="token keyword">def</span> mergeMessage<span class="token punctuation">(</span>count1<span class="token operator">:</span> Map<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">,</span> count2<span class="token operator">:</span> Map<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token operator">:</span> Map<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> map <span class="token operator">=</span> mutable<span class="token punctuation">.</span>Map<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span>count1<span class="token punctuation">.</span>keySet <span class="token operator">++</span> count2<span class="token punctuation">.</span>keySet<span class="token punctuation">)</span><span class="token punctuation">.</span>foreach <span class="token punctuation">&#123;</span> i <span class="token keyword">=></span>      <span class="token keyword">val</span> count1Val <span class="token operator">=</span> count1<span class="token punctuation">.</span>getOrElse<span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span>      <span class="token keyword">val</span> count2Val <span class="token operator">=</span> count2<span class="token punctuation">.</span>getOrElse<span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span>      map<span class="token punctuation">.</span>put<span class="token punctuation">(</span>i<span class="token punctuation">,</span> count1Val <span class="token operator">+</span> count2Val<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    map  <span class="token punctuation">&#125;</span>  <span class="token comment">// Step 2.3: 重设节点标签属性: 当存在邻居节点则设为其最大数量的标签, 否则不变</span>  <span class="token keyword">def</span> vertexProgram<span class="token punctuation">(</span>vid<span class="token operator">:</span> VertexId<span class="token punctuation">,</span> attr<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span> message<span class="token operator">:</span> Map<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> VertexId <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span> attr <span class="token keyword">else</span> message<span class="token punctuation">.</span>maxBy<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token punctuation">)</span><span class="token punctuation">.</span>_1  <span class="token punctuation">&#125;</span>  <span class="token keyword">val</span> initialMessage <span class="token operator">=</span> Map<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Step 2: 利用 Pregel 函数实际调用算法</span>  Pregel<span class="token punctuation">(</span>lpaGraph<span class="token punctuation">,</span> initialMessage<span class="token punctuation">,</span> maxIterations <span class="token operator">=</span> maxSteps<span class="token punctuation">)</span><span class="token punctuation">(</span>    vprog <span class="token operator">=</span> vertexProgram<span class="token punctuation">,</span>    sendMsg <span class="token operator">=</span> sendMessage<span class="token punctuation">,</span>    mergeMsg <span class="token operator">=</span> mergeMessage<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>由于对于无权图, 其邻居很可能多个最大标签, 此时随机选择, 则可能造成较大传播误差; 实际生产环境大多是带权图, 如果可利用边权进行传播则相对稳定.</p><figure><div class="code-wrapper"><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">// 直接将边权作为数值传递</span><span class="token keyword">def</span> sendMessage<span class="token punctuation">(</span>e<span class="token operator">:</span> EdgeTriplet<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> ED<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token punctuation">[</span><span class="token punctuation">(</span>VertexId<span class="token punctuation">,</span> Map<span class="token punctuation">[</span>VertexId<span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  Iterator<span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>srcId<span class="token punctuation">,</span> Map<span class="token punctuation">(</span>e<span class="token punctuation">.</span>dstAttr <span class="token operator">-></span> e<span class="token punctuation">.</span>attr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>dstId<span class="token punctuation">,</span> Map<span class="token punctuation">(</span>e<span class="token punctuation">.</span>srcAttr <span class="token operator">-></span> e<span class="token punctuation">.</span>attr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>除此以外, 针对风控等场景通过专家规则等可获得部分正样本(黑样本), 此时调用算法则是想传播该部分标签, 可在初始化时不使用 <code>VertexId</code> 作为标签类型, 而是直接标记 正负样本 <code>Long&#123;0, 1&#125;</code>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/LittleHann/p/10699988.html">标签传播算法（Label Propagation Algorithm, LPA）初探</a></li><li><a href="https://zhuanlan.zhihu.com/p/511796578">社区发现之标签传播算法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Community Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Community Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【社区发现算法】Walktrap算法</title>
    <link href="/1876331717.html"/>
    <url>/1876331717.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Community Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Community Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【社区发现算法】GN算法</title>
    <link href="/1053869063.html"/>
    <url>/1053869063.html</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在社会生活中, 图的概念无处不在, 如社交网络, 即自然人作为节点, 而人与人之间的社交关系则是边, 人与人之间的团体即为社区。上述是比较直观的描述, 如下则是更加具体的定义:</p><ul><li>社区(<code>community</code>): 社区是图的一个子图，相比于图的其他部分，其中包含着密集的节点.</li></ul><p>而如何查找图中的社区则是社区发现的内容, 在2004年, Newman 和 Girvan的论文中提出了利用介数中心性(betweenness centrality)的方法，称之为 <code>Girvan-Newman</code> 算法.</p><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>介数中心性(<code>betweenness centrality</code>): 基于最短路径的图的中心的度量方法</p><p>$$<br>C_{B}(v) &#x3D; \sum_{s \ne v \ne t \in V} \frac{\sigma_{st}(v)}{\sigma_{st}}<br>$$</p><ul><li>其中 $\sigma_{st}$ 代表节点 <code>s-&gt;t</code> 的最短路径数, $\sigma_{st}(v)$ 代表节点 <code>s-&gt;t</code> 且经过节点 <code>v</code> 的最短路径数</li></ul><p>根据公式, 社区之间的边，值更大; 社区内部的边, 值更小. 若将节点 <code>v</code> 剔除, 则可以将两个社区分割.</p><p>上述公式给予社区发现过程中 <code>社区之间的边</code> 的选择方法, 将其切割即可拆分社区, 但拆分成几个社区, 则需要新的指标进行评估. 即模块度函数 $Q$ 来定量的衡量社区划分的结果.</p><p>假设已经发现复杂网络的社区结构, $M$ 为已发现的社区个数, $L$ 为网络中的边数, $l_s$ 是社区 <code>s</code> 中节点相互连接的数目, $d_s$ 是社区 <code>s</code> 中所有节点相互连接数目的和。则 $Q$ 的函数表达式如下所示:</p><p>$$<br>Q &#x3D; \sum_{s}^{M} \lbrack \frac{l_s}{L} - (\frac{d_s}{2L})^2 \rbrack<br>$$</p><blockquote><p>物理意义: 网络中连接两个同种类型的节点的边(即社区内部边)比例, 减去在同样的社区结构下任意连接这两个节点的边的比例的期望值.</p></blockquote><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p><code>Girvan-Newman</code> 算法的基本流程如下:</p><ol><li>计算网络中所有边的边介数</li><li>找到边介数最高的边并将它从网络中移除</li><li>重复步骤2, 直到每个节点成为一个独立的社区为止, 即网络中没有边存在.</li></ol><p>最终选择社区情况, 即通过遍历拆分成 <code>1-N</code> 社区的模块度 $Q_n$, 选择其中最大模块度的社区结果.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://sikasjc.github.io/2017/12/20/GN/">GN算法–复杂网络中社区发现与Python实现</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Community Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Community Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【社区发现算法】Louvain算法</title>
    <link href="/116063852.html"/>
    <url>/116063852.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Louvain算法是基于模块度的社区发现算法，能够发现层次性的社区结构，其优化目标是最大化整个社区网络的模块度。其算法论文发表自2008年，原文为<a href="https://arxiv.org/abs/0803.0476">Fast unfolding of communities in large networks</a>。</p><h2 id="模块度-Modularity"><a href="#模块度-Modularity" class="headerlink" title="模块度(Modularity)"></a>模块度(Modularity)</h2><p>模块度是评估一个社区网络划分好坏的度量方法。</p><blockquote><p>模块度的定义社区内节点之间的实际连边数与随机情况下连边数的差值。其物理意义是：模块度越大，同一个社区内的节点之间联系更加紧密，不同社区之间的节点联系更加松散。</p></blockquote><p>对于一个有 $n$ 个节点， $m$ 条边的网络，其中节点 $v$ 有 $k_v$ 条边(即节点 $v$ 的度为 $k_v$)，其模块度公式定义如下:</p><p>$$<br>\begin{aligned}<br>Q &#x3D; \frac{1}{2m} \sum_{i,j} \lbrack A_{ij} - \frac{k_i k_j}{2m} \rbrack \<br>\delta(u,v) &#x3D; \lbrace_{0\ else}^{1 when\ u &#x3D;&#x3D; v}<br>\end{aligned}<br>$$</p><p>其中</p><ul><li>$A_{ij}$ 表示节点 $i$ 和节点 $j$ 之间的权重，当网络为无权图，权重均为1</li><li>$k_i &#x3D; \sum_{j} A_{ij}$ 即节点 $i$ 的权重之和(无权图即度数)</li><li>$c_i$ 表示节点 $i$ 所属社区</li><li>$m &#x3D; \frac{1}{2}\sum_{i,j} A_{ij}$即所有边权重之和(无权图即边的数量)</li></ul><p>公式内部 $A_{ij} - \frac{k_i k_j}{2m}$ 代表节点 $i$ 与 节点 $j$ 相连实际与期望的差, $\frac{k_i k_j}{2m}$ 表示节点 $i$ 与 节点 $j$ 在 $2m$ 个边节点中存在 $k_i k_j$ 个可能。</p><p>设 $\sum in$ 代表社区 $c$ 内的边权重之和, $\sum tot$ 代表与社区 $c$ 内的节点相连的边权重之和。</p><p>$$<br>\begin{aligned}<br>Q<br>&amp;&#x3D; \frac{1}{2m}[\sum_{i,j}A_{ij} - \frac{\sum_ik_i\sum_jk_j}{2m}]\delta(c_i,c_j) \<br>&amp;&#x3D; \sum_{c} \lbrack \frac{\sum in}{2m} - (\frac{\sum tot}{2m})^2 \rbrack \<br>&amp;&#x3D; \sum_{c} \lbrack e_c - a_c^2 \rbrack<br>\end{aligned}<br>$$</p><p>这样模块度可以理解为 <strong>社区内部边的权重和</strong> 减去 <strong>所有与社区内节点相连的边的权重和</strong> 的平方。对于无权图，模块度为 <strong>社区内部的度数</strong> 减去 <strong>社区内节点的总度数</strong> 的平方。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>初始化图中节点均为一个独立社区(即节点数为社区数)</li><li>对于每个节点 $i$ 依次将其分配到其邻居所属社区，计算分配前后模块度差值的 $Q_{cur} - Q_{pre}$, 将节点 $i$ 分配至 <strong>差值大于0且最大</strong> 的邻居所属社区中, 否则保持不变</li><li>重复步骤2，直至所有节点的所属社区不在变化</li><li>对图进行压缩, 所有在同一社区的节点压缩成一个新的节点，此时边权等<strong>均可能</strong>发生变化</li><li>重复步骤1，直至整个图的模块度无法增益</li></ol><p>从步骤中可以看出步骤2中节点顺序对分群结果有所影响，其中步骤二的公式可以简化成如下的形式: </p><p>$$<br>\begin{aligned}<br>\Delta Q<br>&amp;&#x3D; \lbrack \frac{\sum_{in}+ k_{i,in}}{2m}-(\frac{\sum_{tot}+k_i}{2m})^2 \rbrack- \lbrack \frac{\sum_{in}}{2m}-(\frac{\sum_{tot}}{2m})^2-(\frac{k_i}{2m})^2 \rbrack \<br>&amp;&#x3D; \lbrack \frac{k_{i,in}}{2m}-\frac{\sum_{tot}k_i}{2m^2} \rbrack \<br>&amp;&#x3D; 2m \lbrack k_{i,in}-\frac{\sum_{tot}k_i}{m} \rbrack<br>\end{aligned}<br>$$</p><blockquote><p>其中 $k_{i,in}$ 是社区 $c$ 内节点与节点 $i$ 的边权重之和，<strong>注意</strong> $k_{i,in}$ 纳入内部时同时存在原内部节点到节点 $i$ 与节点 $i$ 到原内部节点的权重，因此对应边权重加起来再乘以2。</p></blockquote><p>该公式计算思路是 <code>[i节点加入社群c后的模块度]-[社团c本身的模块]-[i单节点模块度]</code>.</p><h3 id="GraphX调用"><a href="#GraphX调用" class="headerlink" title="GraphX调用"></a>GraphX调用</h3><p>参考代码<a href="https://github.com/vesoft-inc/nebula-algorithm/blob/master/nebula-algorithm/src/main/scala/com/vesoft/nebula/algorithm/lib/LouvainAlgo.scala">LouvainAlgo.scala</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/fengfenggirl/p/louvain.html">模块度与Louvain社区发现算法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Community Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Community Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>风控特征之应用列表信息</title>
    <link href="/3066150691.html"/>
    <url>/3066150691.html</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在当前移动互联网的时代, 移动应用占据人们大量的时间, 该用户手机应用安装使用情况也可以反应其身份习惯, 如大量借贷软件的安装使用可能反应该用户存在欺诈风险. 对于风控从业人员, 如何处理应用列表信息也是必要的技能, 可以极大提升风控效果.</p><blockquote><p>免责申明: 本文仅讨论相关技术问题, 针对隐私等相关问题, 请遵守相关法律.</p></blockquote><h2 id="应用数据概述"><a href="#应用数据概述" class="headerlink" title="应用数据概述"></a>应用数据概述</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>根据官方<a href="https://developer.android.com/reference/android/content/pm/PackageManager">PackageManager</a>相关接口, 在获取到相关权限后, 通过 <a href="https://developer.android.com/reference/android/content/pm/PackageManager#getInstalledPackages(android.content.pm.PackageManager.PackageInfoFlags)">PackageManager.getInstalledPackages()</a> 获取 <code>PackageInfo</code> 相关信息, 可获取如下信息(以支付宝举例):</p><ul><li><code>pkg_name</code>: 应用包名, &#96;com.eg.android.AlipayGphone&#96;&#96;</li><li><code>app_name</code>: 应用名称, <code>支付宝</code></li><li><code>app_version</code>: 应用版本, <code>10.5.28.8100</code></li><li><code>is_system_app</code>: 是否系统应用</li></ul><p>如上数据根据相关权限可以获取成如下两种形式</p><ul><li><strong>应用安装列表(App List)</strong>: 该类型主要是设备上应用信息的聚合, 无时序信息, 因此无序, 侧重于反应当前用户的情况<ul><li><code>ARRAY(pkg_name, app_name, app_version)</code></li></ul></li><li><strong>应用安装序列(App Seq)</strong>: 该类型相较于应用安装列表信息更全, 可涵盖设备应用的变化信息, 侧重于反应用户变化的情况<ul><li><code>ARRAY(pkg_name, app_name, action_time, action_type, app_version)</code></li></ul></li></ul><h3 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h3><p>以 <code>支付宝</code> 应用举例, 参考 <a href="https://sj.qq.com/appdetail/com.eg.android.AlipayGphone">腾讯应用宝-支付宝</a>, 可通过应用商店等第三方获取应用的描述信息, 通常包括:</p><ul><li><strong>应用分类</strong>: 如 <code>基金</code>, <code>支付</code> 等</li><li><strong>下载量级</strong>: 如 <code>12亿</code></li><li><strong>应用描述</strong>: 针对工具类的应用, 通常作者会在描述中写清其功能, 包括 <code>篡改IMEI</code> 等</li></ul><blockquote><p>除此以外通常还包含如评论评分等内容, 但由于受限于使用人, 且存在刷分等情况, 因此建议慎重使用.</p></blockquote><h2 id="应用数据应用"><a href="#应用数据应用" class="headerlink" title="应用数据应用"></a>应用数据应用</h2><h3 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h3><p>根据应用信息, 最基本的处理方法就是 <code>判断是否安装某个应用</code>, 举例 <code>用户是否安装Xposed框架</code>, 初级则是通过应用名称去匹配, 即 <code>app_name = &#39;Xposed Installer&#39;</code>, 但实际上根据安装渠道、系统设置等, 应用名称也会有所变化, 因此通常都是基于 <code>pkg_name = &#39;de.robv.android.xposed.installer&#39;</code> 进行处理, 该处理虽然简单, 但实际使用也比较有效, 可以作为基础策略使用.</p><p>由于风控人力基本较为紧张, 无法穷举所有风险应用, 且风险应用在大量增加, 因此如何快速进行特征提取则尤为关键.</p><ol><li><p><code>pkg_name(de.robv.android.xposed.installer)</code> 特征提取</p><ul><li><strong>应用类别</strong>: 通常是由 <strong>&lt;归属前缀&gt;.&lt;应用名称&gt;</strong>, 虽然该规范并非强制, 但可提取其前缀作为应用的属性信息, 通常提取前两段即可</li><li><strong>关键词汇</strong>: <code>pkg_name</code> 由字母组成, 由此可以进行分词, 针对其中的信息进行提取, 如 <code>xposed</code> 词等; 但部分应用很难进行分析, 可以采用 <code>n-gram</code>切片的方式, 若 <code>N=3</code>, 示例可切成 <code>de.</code>, <code>e.r</code>等等</li></ul></li><li><p><code>app_name(Xposed Installer)</code> 与描述信息 特征提取</p><ul><li><strong>关键词汇</strong>: 可以进行中文分词, 然后进行关键词匹配, 如统计 <code>借</code>, <code>贷</code>, <code>花</code> 等关键词以反应金融欺诈风险</li><li><strong>词汇向量</strong>: 将 <code>app_name</code> 看做单词, 可以根据 <strong>应用商店的分类信息</strong>, <strong>应用列表的共现信息</strong> 去训练词向量.</li></ul></li></ol><blockquote><p>如上更多从 <strong>负向(风险)</strong> 维度去考虑, 也可通过 <strong>正向(价值)</strong> 维度思量, 即安装某些应用其风险较低.</p></blockquote><p>获取到上述基础特征后, 通常具备如下加工的方式, 主要是统计特征:</p><ul><li><strong>现有情况</strong>: 统计该用户在时间窗口(7&#x2F;30&#x2F;90天等)内 <strong>安装特定或某类应用</strong> 的数量和占比</li><li><strong>变化情况</strong>: 统计该用户在时间窗口(7&#x2F;30&#x2F;90天等)与上一个时间窗口在 <strong>安装特定或某类应用</strong> 的数量和占比的 <strong>变化趋势</strong></li></ul><p>实际上很多风控部门无应用的标签, 其相应风险需要风控同学自己进行挖掘, 即风险应用或应用标签等, 如下提供一些较为实用的思路:</p><ol><li>基于应用语义: 即通过应用名、功能描述等，进行关键词查找定位筛选</li><li>基于安装规模: 即风险应用相对小众, 可以按照少量安装量进行筛选, 但注意如果场景作弊量大, 可能该方法效果较差, 而且通常会筛选出大量非风险应用(即黄暴类、游戏类)</li><li>基于TF-IDF: 该类型需要有<strong>前置标签</strong>, 但是相较于 <strong>方法2</strong> 实际效果好很多<ul><li>TF &#x3D; 安装某App的逾期用户数 &#x2F; 所有逾期用户数。用以衡量该App对于逾期风险的代表性</li><li>IDF &#x3D; Log(所有用户数 &#x2F; 安装某App的用户数)。用以衡量该App安装的普遍性。</li></ul></li><li>基于规则分箱: 该方法主要应用于难以构建应用标签的场景<ul><li>预装应用: 针对预装&#x2F;系统应用进行分箱, 可观测其设备是否与其品牌相符</li><li>国民应用: 国民应用如微信等, 需要单独处理</li><li>小众应用: 安装量极低, 其在TF-IDF等筛选上不稳定, 因此若量级较大, 可以先粗箱处理, 后语义等细箱</li></ul></li></ol><h3 id="向量模型"><a href="#向量模型" class="headerlink" title="向量模型"></a>向量模型</h3><p>如果风控同学所具备的应用数据较多, 可以考虑 <code>word2vec</code> 或 <code>item2vec</code> 等方式, 但主要进行一定的应用预筛. 除此外, 应用列表向量化具有<a href="https://ieeexplore.ieee.org/document/7752297">App2Vec: Vector Modeling of Mobile Apps and Applications</a>模型</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/78413058">风控数据—手机App数据挖掘实践思路</a></li><li><a href="https://zhuanlan.zhihu.com/p/208931125">风控模型之APPList模型</a></li><li><a href="https://zhuanlan.zhihu.com/p/506161408">APP设备数据的特征衍生与模型应用</a></li><li><a href="https://zhuanlan.zhihu.com/p/362481702">事半功倍的手机APP特征工程，你会吗？</a></li><li><a href="http://www.shazhao.net/papers/cccf.pdf">利用智能手机Apps的用户画像</a></li><li><a href="https://zhuanlan.zhihu.com/p/463937728">APPlist介绍与挖掘思路</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>risk control</category>
      
    </categories>
    
    
    <tags>
      
      <tag>risk control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Hexo 搭建个人博客网站</title>
    <link href="/128448416.html"/>
    <url>/128448416.html</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="相关插件"><a href="#相关插件" class="headerlink" title="相关插件"></a>相关插件</h2><p><a href="https://ziyuan.baidu.com/site/index">百度站长-站点管理</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hui-wang.info/2016/10/23/Hexo%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%B8%BB%E5%8A%A8%E6%8F%90%E4%BA%A4%E9%93%BE%E6%8E%A5/">Hexo插件之百度主动提交链接</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Server Build</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【模型可解释】 Shap</title>
    <link href="/1116592221.html"/>
    <url>/1116592221.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SHAP（SHapley Additive exPlanations）是一种博弈论方法, 用于解释任何机器学习模型的输出.</p><ul><li>理论基础: <a href="https://arxiv.org/abs/1705.07874">A Unified Approach to Interpreting Model Predictions</a></li><li><a href="https://github.com/slundberg/shap">Github 官方仓库</a></li></ul><h2 id="Shapley-value"><a href="#Shapley-value" class="headerlink" title="Shapley value"></a>Shapley value</h2><p><code>Shapley value</code> 起源于合作博弈论, 诺贝尔经济学奖得主 <code>Lloyd S. Shapley</code> 于 1953 年针对如下问题, 提出一个合理的计算方法, 每个参与者分配到的数额称为 <code>Shapley value</code>.</p><blockquote><p>博弈问题: <code>N</code> 个人合作, 创造 <code>v(N)</code> 的价值, 对所创造的价值进行分配的问题.</p></blockquote><p>满足分配四大原则:</p><ol><li>有效性(Efficiency): 所有价值均被分配</li><li>对称性(Symmetry): 假设两者可相互替代, 其收益应该一样</li><li>Dummy: 未贡献则收益为0</li><li>可加性(Additivity): 如果同一批人完成两项任务, 那么两项任务的收益一起分配应该和分开分配结果一致</li></ol><p><code>Shapley value</code> 公式为:</p><p>$$<br>\phi_i(N, v) &#x3D; \sum_{S \in N \setminus { i }} \frac{|S|!(|N| - |s| - 1)!}{|N|!}(v(S \cup {i}) - v(S))<br>$$</p><p>计算示例参见<a href="https://www.zhihu.com/question/23180647">卫宫切嗣 的知乎回答</a></p><h2 id="XGBOOST在Spark的Shap计算验证"><a href="#XGBOOST在Spark的Shap计算验证" class="headerlink" title="XGBOOST在Spark的Shap计算验证"></a>XGBOOST在Spark的Shap计算验证</h2><p>验证环境:</p><ul><li>spark: 3.0.1 scala: 2.12.10 xgboost4j-spark: 1.5.0</li><li>python: 3.6 xgboost: 1.5.0 shap: 0.38.1</li></ul><blockquote><p>结论: 测试随机生成1W条数据, 每条数据3个特征, 单条条数三个, 单条数据最大绝对误差为9.99e-09(scala, python结果同时8位精度), 计算结果相同</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> originData <span class="token operator">=</span>  spark<span class="token punctuation">.</span>createDataFrame<span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token keyword">new</span> Array<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>x <span class="token keyword">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> f1 <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>math<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">val</span> f2 <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>math<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">val</span> f3 <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>math<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">val</span> label <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>f1 <span class="token operator">+</span> f2 <span class="token operator">+</span> f3<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span>    <span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">,</span> label<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toDF<span class="token punctuation">(</span><span class="token string">"f1"</span><span class="token punctuation">,</span> <span class="token string">"f2"</span><span class="token punctuation">,</span> <span class="token string">"f3"</span><span class="token punctuation">,</span> <span class="token string">"label"</span><span class="token punctuation">)</span> <span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>ml<span class="token punctuation">.</span>feature<span class="token punctuation">.</span></span>VectorAssembler<span class="token keyword">val</span> assembler <span class="token operator">=</span> <span class="token keyword">new</span> VectorAssembler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setInputCols<span class="token punctuation">(</span>Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">"f1"</span><span class="token punctuation">,</span> <span class="token string">"f2"</span><span class="token punctuation">,</span> <span class="token string">"f3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setOutputCol<span class="token punctuation">(</span><span class="token string">"features"</span><span class="token punctuation">)</span><span class="token keyword">val</span> featureData <span class="token operator">=</span> assembler<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>originData<span class="token punctuation">)</span> <span class="token keyword">import</span> <span class="token namespace">ml<span class="token punctuation">.</span>dmlc<span class="token punctuation">.</span>xgboost4j<span class="token punctuation">.</span>scala<span class="token punctuation">.</span>spark<span class="token punctuation">.</span></span>XGBoostClassifier<span class="token keyword">val</span> xgb <span class="token operator">=</span> <span class="token keyword">new</span> XGBoostClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setLabelCol<span class="token punctuation">(</span><span class="token string">"label"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setFeaturesCol<span class="token punctuation">(</span><span class="token string">"features"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setObjective<span class="token punctuation">(</span><span class="token string">"binary:logistic"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setNumRound<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">val</span> xgbModel <span class="token operator">=</span> xgb<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>featureData<span class="token punctuation">)</span>xgbModel<span class="token punctuation">.</span>setContribPredictionCol<span class="token punctuation">(</span><span class="token string">"raw_feature_shap"</span><span class="token punctuation">)</span> <span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>functions<span class="token punctuation">.</span></span><span class="token punctuation">&#123;</span>col<span class="token punctuation">,</span> udf<span class="token punctuation">&#125;</span><span class="token keyword">val</span> formatShap <span class="token operator">=</span> udf<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">:</span> Seq<span class="token punctuation">[</span><span class="token builtin">Double</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span> x<span class="token punctuation">.</span>map<span class="token punctuation">(</span>x <span class="token keyword">=></span> x<span class="token punctuation">.</span>formatted<span class="token punctuation">(</span><span class="token string">"%.8f"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>ml<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span></span><span class="token punctuation">&#123;</span>Vector <span class="token keyword">=></span> oldVectors<span class="token punctuation">&#125;</span><span class="token keyword">val</span> formatFeature <span class="token operator">=</span> udf<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">:</span> oldVectors<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span> x<span class="token punctuation">.</span>toArray<span class="token punctuation">.</span>map<span class="token punctuation">(</span>x <span class="token keyword">=></span> x<span class="token punctuation">.</span>formatted<span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">val</span> result <span class="token operator">=</span> xgbModel<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>featureData<span class="token punctuation">)</span><span class="token punctuation">.</span>withColumn<span class="token punctuation">(</span>    <span class="token string">"feature_shap"</span><span class="token punctuation">,</span> formatShap<span class="token punctuation">(</span>col<span class="token punctuation">(</span><span class="token string">"raw_feature_shap"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>withColumn<span class="token punctuation">(</span>    <span class="token string">"feature"</span><span class="token punctuation">,</span> formatFeature<span class="token punctuation">(</span>col<span class="token punctuation">(</span><span class="token string">"features"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">"feature"</span><span class="token punctuation">,</span> <span class="token string">"feature_shap"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repartition<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span> result<span class="token punctuation">.</span>write<span class="token punctuation">.</span>option<span class="token punctuation">(</span><span class="token string">"header"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>option<span class="token punctuation">(</span><span class="token string">"delimiter"</span><span class="token punctuation">,</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>csv<span class="token punctuation">(</span><span class="token string">"result.txt"</span><span class="token punctuation">)</span>xgbModel<span class="token punctuation">.</span>nativeBooster<span class="token punctuation">.</span>saveModel<span class="token punctuation">(</span><span class="token string">"model.pkl"</span><span class="token punctuation">)</span>  <span class="token comment">// hadoop fs -get ./result.txt/part-00000-*.csv result.csv</span><span class="token comment">// hadoop fs -rm -r ./result.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shap<span class="token keyword">import</span> xgboost <span class="token keyword">as</span> xgb<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd model <span class="token operator">=</span> xgb<span class="token punctuation">.</span>Booster<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'nthread'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>load_model<span class="token punctuation">(</span><span class="token string">"model.pkl"</span><span class="token punctuation">)</span>explainer <span class="token operator">=</span> shap<span class="token punctuation">.</span>TreeExplainer<span class="token punctuation">(</span>model<span class="token punctuation">)</span> scala_result <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'result.csv'</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">'\t'</span><span class="token punctuation">)</span>scala_result<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#              feature                                    feature_shap</span><span class="token comment"># 0  1.00,40.00,855.00  -0.02117009,0.01038337,-0.04706362,-0.00467462</span><span class="token comment"># 1  6.00,35.00,584.00  -0.00913048,-0.00514835,0.01143846,-0.00467462</span><span class="token comment"># 2  9.00,83.00,366.00  -0.00465891,0.00696741,-0.00735373,-0.00467462</span><span class="token comment"># 3  5.00,24.00,788.00  -0.01884035,0.02896836,-0.00291048,-0.00467462</span><span class="token comment"># 4   8.00,81.00,42.00   0.01391302,-0.01803247,0.04461136,-0.00467462</span> feature <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>scala_result<span class="token punctuation">[</span><span class="token string">'feature'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> expand <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>values<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'float'</span><span class="token punctuation">)</span>python_result <span class="token operator">=</span> explainer<span class="token punctuation">.</span>shap_values<span class="token punctuation">(</span>feature<span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>explainer<span class="token punctuation">.</span>expected_value<span class="token comment"># -0.0046746163</span> <span class="token keyword">for</span> index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">format</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'.1f'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> feature<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token builtin">format</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'.8f'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> python_result<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># ['1.0', '40.0', '855.0'] ['-0.02117009', '0.01038337', '-0.04706362']</span><span class="token comment"># ['6.0', '35.0', '584.0'] ['-0.00913048', '-0.00514835', '0.01143846']</span><span class="token comment"># ['9.0', '83.0', '366.0'] ['-0.00465891', '0.00696741', '-0.00735373']</span><span class="token comment"># ['5.0', '24.0', '788.0'] ['-0.01884035', '0.02896836', '-0.00291048']</span><span class="token comment"># ['8.0', '81.0', '42.0'] ['0.01391302', '-0.01803247', '0.04461136']</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>scala_result<span class="token punctuation">[</span><span class="token string">'feature_shap'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> expand <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'float'</span><span class="token punctuation">)</span> <span class="token operator">-</span> python_result<span class="token punctuation">)</span><span class="token punctuation">,</span> axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 1.4835780859888403e-08</span>np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>    np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>        np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>scala_result<span class="token punctuation">[</span><span class="token string">'feature_shap'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> expand <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'float'</span><span class="token punctuation">)</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>around<span class="token punctuation">(</span>python_result<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        axis <span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 9.999999994736442e-09</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="坑一-LGB-基准值问题"><a href="#坑一-LGB-基准值问题" class="headerlink" title="坑一: LGB 基准值问题"></a>坑一: LGB 基准值问题</h3><p>问题描述: 直接调用 <code>shap.TreeExplainer(model)</code> 取解析模型, 其基准值基于 <code>Train data</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 预测集</span>X <span class="token operator">=</span> test_data<span class="token punctuation">.</span>values<span class="token comment"># 基于预测集的解释器</span>explainer <span class="token operator">=</span> shap<span class="token punctuation">.</span>TreeExplainer<span class="token punctuation">(</span>model<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="坑二-LGB-输出值与SHAP和不等"><a href="#坑二-LGB-输出值与SHAP和不等" class="headerlink" title="坑二: LGB 输出值与SHAP和不等"></a>坑二: LGB 输出值与SHAP和不等</h3><p>问题描述: <code>TreeExplainer</code> 无法直接解析 LGB 模型的概率输出</p><p>方法一: Sigmoid 还原概率结果</p><p>$$<br>y_{prob} &#x3D; \frac{1}{1 + e^{-y_{raw}}} \rightarrow y_{raw} &#x3D; \log \frac{y}{1 - y_{prob}}<br>$$</p><p>方法二: 直接解析概率结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">explainer <span class="token operator">=</span> shap<span class="token punctuation">.</span>TreeExplainer<span class="token punctuation">(</span>    model<span class="token punctuation">,</span> data <span class="token operator">=</span> X<span class="token punctuation">,</span>    model_output <span class="token operator">=</span> <span class="token string">"probability"</span><span class="token punctuation">,</span>    feature_dependence <span class="token operator">=</span> <span class="token string">"independent"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/23180647">卫宫切嗣 的知乎回答</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Model Explainable</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shap</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
